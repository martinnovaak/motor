#ifndef MOTOR_EVALUATION_HPP
#define MOTOR_EVALUATION_HPP

#include <cstdint>
#include "../chess_board/board.hpp"

[[nodiscard]] constexpr std::int32_t S(const int32_t mg, const int32_t eg) {
    return (eg << 16) + mg;
}

constexpr std::int16_t game_phase_increment[6] = {0, 1, 1, 2, 4, 0};
constexpr std::int16_t max_game_phase_value = 24;

constexpr std::int32_t piece_square_tables[6][64] = {
    {
       S( 100, 100), S( 100, 100), S( 100, 100), S( 100, 100), S( 100, 100), S( 100, 100), S( 100, 100), S( 100, 100),
       S( 204, 266), S( 240, 257), S( 203, 234), S( 224, 194), S( 219, 206), S( 185, 232), S(  68, 280), S(   1, 302),
       S(  89, 184), S( 117, 171), S( 126, 146), S( 146,  93), S( 168, 104), S( 192, 133), S( 169, 164), S( 107, 163),
       S(  67, 169), S(  99, 160), S(  91, 134), S( 109, 113), S( 114, 128), S( 109, 138), S( 120, 153), S(  78, 148),
       S(  56, 156), S(  86, 151), S(  87, 129), S(  99, 119), S( 118, 126), S( 109, 131), S( 122, 142), S(  76, 131),
       S(  60, 140), S(  81, 146), S(  77, 122), S(  82, 128), S(  99, 131), S( 101, 126), S( 149, 127), S(  98, 119),
       S(  52, 151), S(  82, 146), S(  66, 134), S(  54, 120), S(  78, 144), S( 128, 127), S( 158, 126), S(  93, 118),
       S( 100, 100), S( 100, 100), S( 100, 100), S( 100, 100), S( 100, 100), S( 100, 100), S( 100, 100), S( 100, 100),
       },
    {
       S( 217, 351), S( 260, 397), S( 355, 411), S( 407, 381), S( 472, 385), S( 280, 410), S( 391, 345), S( 295, 290),
       S( 344, 388), S( 348, 433), S( 451, 409), S( 445, 436), S( 424, 427), S( 483, 386), S( 417, 382), S( 379, 374),
       S( 337, 414), S( 437, 416), S( 420, 457), S( 446, 459), S( 524, 428), S( 572, 417), S( 457, 419), S( 436, 380),
       S( 388, 410), S( 396, 451), S( 415, 468), S( 433, 478), S( 408, 475), S( 442, 468), S( 403, 451), S( 419, 409),
       S( 367, 411), S( 389, 429), S( 400, 464), S( 390, 472), S( 411, 468), S( 391, 470), S( 408, 440), S( 376, 400),
       S( 347, 392), S( 372, 425), S( 384, 446), S( 384, 458), S( 405, 449), S( 392, 419), S( 390, 416), S( 350, 401),
       S( 329, 379), S( 316, 415), S( 365, 414), S( 385, 419), S( 375, 429), S( 395, 398), S( 376, 390), S( 362, 374),
       S( 248, 381), S( 353, 370), S( 312, 414), S( 348, 412), S( 367, 393), S( 382, 382), S( 354, 362), S( 308, 352),
       },
    {
       S( 385, 455), S( 403, 458), S( 342, 466), S( 366, 466), S( 355, 467), S( 373, 468), S( 438, 442), S( 396, 454),
       S( 367, 465), S( 411, 485), S( 397, 490), S( 414, 477), S( 421, 483), S( 466, 463), S( 395, 481), S( 375, 445),
       S( 393, 473), S( 425, 478), S( 437, 489), S( 444, 492), S( 456, 491), S( 516, 492), S( 477, 477), S( 425, 471),
       S( 390, 466), S( 410, 492), S( 431, 494), S( 441, 521), S( 420, 522), S( 442, 504), S( 407, 497), S( 403, 474),
       S( 416, 463), S( 418, 484), S( 414, 505), S( 423, 521), S( 434, 507), S( 403, 498), S( 409, 483), S( 421, 454),
       S( 406, 463), S( 424, 476), S( 413, 495), S( 413, 510), S( 409, 496), S( 414, 481), S( 420, 472), S( 402, 458),
       S( 423, 442), S( 414, 449), S( 419, 467), S( 400, 476), S( 407, 478), S( 429, 456), S( 430, 447), S( 408, 426),
       S( 361, 450), S( 400, 450), S( 394, 433), S( 386, 458), S( 406, 451), S( 384, 450), S( 369, 455), S( 367, 441),
       },
    {
       S( 578, 762), S( 568, 769), S( 584, 771), S( 602, 770), S( 629, 757), S( 607, 763), S( 637, 756), S( 669, 736),
       S( 544, 792), S( 532, 797), S( 577, 790), S( 597, 785), S( 614, 771), S( 649, 746), S( 601, 767), S( 622, 757),
       S( 518, 789), S( 545, 783), S( 538, 787), S( 575, 772), S( 596, 763), S( 624, 750), S( 643, 742), S( 579, 752),
       S( 487, 780), S( 504, 780), S( 524, 784), S( 550, 767), S( 545, 767), S( 563, 767), S( 548, 761), S( 504, 771),
       S( 473, 772), S( 489, 774), S( 501, 779), S( 509, 771), S( 535, 756), S( 508, 753), S( 540, 751), S( 474, 763),
       S( 460, 765), S( 482, 766), S( 491, 763), S( 501, 755), S( 525, 743), S( 524, 732), S( 520, 750), S( 477, 749),
       S( 461, 766), S( 496, 756), S( 494, 763), S( 507, 758), S( 524, 744), S( 527, 736), S( 511, 748), S( 416, 775),
       S( 493, 749), S( 503, 755), S( 514, 765), S( 528, 759), S( 535, 746), S( 531, 752), S( 436, 788), S( 478, 747),
       },
    {
       S(1150, 1289), S(1117, 1360), S(1148, 1340), S(1175, 1311), S(1202, 1327), S(1301, 1268), S(1325, 1244), S(1241,
1300),
       S(1113, 1319), S(1089, 1346), S(1109, 1374), S(1093, 1408), S(1099, 1398), S(1227, 1317), S(1152, 1369), S(1248,
1290),
       S(1136, 1296), S(1119, 1312), S(1118, 1327), S(1139, 1342), S(1173, 1357), S(1243, 1315), S(1214, 1347), S(1195,
1341),
       S(1117, 1302), S(1109, 1328), S(1106, 1331), S(1112, 1347), S(1133, 1344), S(1134, 1351), S(1131, 1379), S(1136,
1382),
       S(1120, 1293), S(1105, 1313), S(1114, 1304), S(1142, 1288), S(1127, 1316), S(1122, 1325), S(1129, 1345), S(1137,
1334),
       S(1122, 1264), S(1134, 1258), S(1120, 1287), S(1119, 1277), S(1121, 1278), S(1133, 1290), S(1141, 1318), S(1128,
1308),
       S(1100, 1285), S(1133, 1253), S(1140, 1243), S(1131, 1269), S(1135, 1265), S(1170, 1205), S(1133, 1221), S(1136,
1268),
       S(1142, 1245), S(1130, 1244), S(1125, 1258), S(1149, 1237), S(1138, 1253), S(1121, 1231), S(1076, 1258), S(1082,
1235),
       },
    {
       S( -12, -57), S(  78, -24), S( 106, -29), S(  49,  -3), S(   8,  14), S(  14,  26), S(  45,  23), S(  15, -14),
       S(  77,  -9), S(  30,  34), S(  21,  32), S(  68,  23), S(  18,  31), S(  19,  49), S(  11,  56), S( -40,  28),
       S(  43,  10), S(  29,  34), S(  16,  38), S(  17,  32), S(   8,  37), S(  50,  48), S(  41,  57), S(  -6,  32),
       S(  11,   1), S(   9,  30), S(  -2,  39), S( -15,  41), S( -18,  39), S(   9,  42), S(  13,  38), S( -51,  21),
       S( -38,  -4), S(  22,   2), S(   1,  25), S( -36,  34), S( -26,  34), S( -18,  30), S( -27,  21), S( -53,   2),
       S(  17, -23), S(  13,  -2), S( -16,  14), S( -33,  24), S( -34,  26), S( -29,  19), S(   0,   5), S( -32,  -3),
       S(  26, -29), S(  -6,  -4), S( -18,   8), S( -65,  17), S( -45,  17), S( -19,   7), S(  14,  -6), S(  26, -24),
       S( -44, -38), S(  19, -28), S(   2, -12), S( -72,  -5), S(   4, -33), S( -46,  -5), S(  33, -30), S(  25, -52),
       },
};
constexpr int32_t passer[8] = {
0, S(  20, 137), S(  13, 152), S(  13,  69), S( -11,  34), S(  -8,   2), S(   3,  -9), 0, };
constexpr int32_t mobility[8] = {
S(   3,  -3), S(   8,   2), S(   2,   9), };

constexpr uint64_t passed_pawn_mask[2][64] = {
        {
                0x0303030303030300, 0x0707070707070700, 0x0e0e0e0e0e0e0e00, 0x1c1c1c1c1c1c1c00, 0x3838383838383800, 0x7070707070707000, 0xe0e0e0e0e0e0e000, 0xc0c0c0c0c0c0c000,
                0x0303030303030000, 0x0707070707070000, 0x0e0e0e0e0e0e0000, 0x1c1c1c1c1c1c0000, 0x3838383838380000, 0x7070707070700000, 0xe0e0e0e0e0e00000, 0xc0c0c0c0c0c00000,
                0x0303030303000000, 0x0707070707000000, 0x0e0e0e0e0e000000, 0x1c1c1c1c1c000000, 0x3838383838000000, 0x7070707070000000, 0xe0e0e0e0e0000000, 0xc0c0c0c0c0000000,
                0x0303030300000000, 0x0707070700000000, 0x0e0e0e0e00000000, 0x1c1c1c1c00000000, 0x3838383800000000, 0x7070707000000000, 0xe0e0e0e000000000, 0xc0c0c0c000000000,
                0x0303030000000000, 0x0707070000000000, 0x0e0e0e0000000000, 0x1c1c1c0000000000, 0x3838380000000000, 0x7070700000000000, 0xe0e0e00000000000, 0xc0c0c00000000000,
                0x0303000000000000, 0x0707000000000000, 0x0e0e000000000000, 0x1c1c000000000000, 0x3838000000000000, 0x7070000000000000, 0xe0e0000000000000, 0xc0c0000000000000,
                0x0300000000000000, 0x0700000000000000, 0x0e00000000000000, 0x1c00000000000000, 0x3800000000000000, 0x7000000000000000, 0xe000000000000000, 0xc000000000000000,
                000000000000000000, 000000000000000000, 000000000000000000, 000000000000000000, 000000000000000000, 000000000000000000, 000000000000000000, 000000000000000000,
        },
        {
                000000000000000000, 000000000000000000, 000000000000000000, 000000000000000000, 000000000000000000, 000000000000000000, 000000000000000000, 000000000000000000,
                0x0000000000000003, 0x0000000000000007, 0x000000000000000e, 0x000000000000001c, 0x0000000000000038, 0x0000000000000070, 0x00000000000000e0, 0x00000000000000c0,
                0x0000000000000303, 0x0000000000000707, 0x0000000000000e0e, 0x0000000000001c1c, 0x0000000000003838, 0x0000000000007070, 0x000000000000e0e0, 0x000000000000c0c0,
                0x0000000000030303, 0x0000000000070707, 0x00000000000e0e0e, 0x00000000001c1c1c, 0x0000000000383838, 0x0000000000707070, 0x0000000000e0e0e0, 0x0000000000c0c0c0,
                0x0000000003030303, 0x0000000007070707, 0x000000000e0e0e0e, 0x000000001c1c1c1c, 0x0000000038383838, 0x0000000070707070, 0x00000000e0e0e0e0, 0x00000000c0c0c0c0,
                0x0000000303030303, 0x0000000707070707, 0x0000000e0e0e0e0e, 0x0000001c1c1c1c1c, 0x0000003838383838, 0x0000007070707070, 0x000000e0e0e0e0e0, 0x000000c0c0c0c0c0,
                0x0000030303030303, 0x0000070707070707, 0x00000e0e0e0e0e0e, 0x00001c1c1c1c1c1c, 0x0000383838383838, 0x0000707070707070, 0x0000e0e0e0e0e0e0, 0x0000c0c0c0c0c0c0,
                0x0003030303030303, 0x0007070707070707, 0x000e0e0e0e0e0e0e, 0x001c1c1c1c1c1c1c, 0x0038383838383838, 0x0070707070707070, 0x00e0e0e0e0e0e0e0, 0x00c0c0c0c0c0c0c0,
        }
};

template <Color color>
std::int16_t evaluate(board & chessboard) {
    std::int32_t eval = 0;
    std::int16_t game_phase = 0;

    for (Piece piece : {Pawn, Knight, Bishop, Rook, Queen, King}) {
        std::uint64_t bitboard = chessboard.get_pieces(White, piece) ;
        while (bitboard) {
            int square = pop_lsb(bitboard) ^ 56;
            eval += piece_square_tables[piece][square];
            game_phase += game_phase_increment[piece];
        }
    }

    for (Piece piece : {Pawn, Knight, Bishop, Rook, Queen, King}) {
        std::uint64_t bitboard = chessboard.get_pieces(Black, piece) ;
        while (bitboard) {
            int square = pop_lsb(bitboard);
            eval -= piece_square_tables[piece][square];
            game_phase += game_phase_increment[piece];
        }
    }

    uint64_t wp, bp, white_pawns, black_pawns;
    wp = white_pawns = chessboard.get_pieces(White, Pawn);
    bp = black_pawns = chessboard.get_pieces(Black, Pawn);
    int white_pawn_count = popcount(wp);
    int black_pawn_count = popcount(bp);

    if ((white_pawn_count + black_pawn_count) == 0 && game_phase < 2) {
        return 0;
    }

    while(wp) {
        int square = pop_lsb(wp);
        if ((passed_pawn_mask[White][square] & black_pawns) == 0) {
            eval += passer[(square >> 3) ^ 7];
        }
    }

    while(bp) {
        int square = pop_lsb(bp);
        if ((passed_pawn_mask[Black][square] & white_pawns) == 0) {
            eval -= passer[(square >> 3)];
        }
    }

    uint64_t occ = chessboard.get_occupancy();
    uint64_t bitboard = chessboard.get_pieces(White, Bishop);
    while (bitboard) {
        eval += mobility[0] * popcount(attacks<Ray::BISHOP>(pop_lsb(bitboard), occ));
    }

    bitboard = chessboard.get_pieces(Black, Bishop);
    while (bitboard) {
        eval -= mobility[0] * popcount(attacks<Ray::BISHOP>(pop_lsb(bitboard), occ));
    }

    bitboard = chessboard.get_pieces(White, Rook);
    while (bitboard) {
        eval += mobility[1] * popcount(attacks<Ray::ROOK>(pop_lsb(bitboard), occ));
    }

    bitboard = chessboard.get_pieces(Black, Rook);
    while (bitboard) {
        eval -= mobility[1] * popcount(attacks<Ray::ROOK>(pop_lsb(bitboard), occ));
    }

    bitboard = chessboard.get_pieces(White, Queen);
    while (bitboard) {
        eval += mobility[2] * popcount(attacks<Ray::QUEEN>(pop_lsb(bitboard), occ));
    }

    bitboard = chessboard.get_pieces(Black, Queen);
    while (bitboard) {
        eval -= mobility[2] * popcount(attacks<Ray::QUEEN>(pop_lsb(bitboard), occ));
    }

    game_phase = std::min(game_phase, max_game_phase_value);

    auto mg_eval = static_cast<int16_t>(eval);
    auto eg_eval = static_cast<int16_t>(eval >> 16);

    if constexpr (color == White) {
        return static_cast<std::int16_t>( (mg_eval * game_phase + eg_eval * (24 - game_phase)) / 24);
    } else {
        return static_cast<std::int16_t>(-(mg_eval * game_phase + eg_eval * (24 - game_phase)) / 24);
    }
}


#endif //MOTOR_EVALUATION_HPP
