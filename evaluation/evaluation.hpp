#ifndef MOTOR_EVALUATION_HPP
#define MOTOR_EVALUATION_HPP

#include <cstdint>
#include "../chess_board/board.hpp"

[[nodiscard]] constexpr std::int32_t S(const int32_t mg, const int32_t eg) {
    return (eg << 16) + mg;
}

constexpr std::int16_t game_phase_increment[6] = {0, 1, 1, 2, 4, 0};
constexpr std::int16_t max_game_phase_value = 24;

constexpr std::int32_t piece_square_tables[6][64] = {
        {
                S( 100, 100), S( 100, 100), S( 100, 100), S( 100, 100), S( 100, 100), S( 100, 100), S( 100, 100), S( 100, 100),
                S( 211, 261), S( 242, 254), S( 197, 236), S( 223, 193), S( 209, 210), S( 172, 230), S(  75, 275), S(   3, 302),
                S(  88, 179), S( 114, 170), S( 123, 141), S( 138,  92), S( 159, 100), S( 185, 131), S( 166, 159), S( 108, 160),
                S(  64, 164), S(  95, 155), S(  88, 132), S( 105, 111), S( 114, 124), S( 107, 133), S( 118, 149), S(  77, 143),
                S(  55, 151), S(  82, 147), S(  85, 126), S(  98, 117), S( 113, 125), S( 104, 128), S( 119, 137), S(  74, 127),
                S(  57, 136), S(  79, 142), S(  76, 120), S(  81, 127), S(  99, 129), S(  98, 124), S( 143, 125), S(  94, 116),
                S(  50, 146), S(  81, 141), S(  65, 130), S(  58, 126), S(  83, 140), S( 124, 124), S( 153, 123), S(  89, 114),
                S( 100, 100), S( 100, 100), S( 100, 100), S( 100, 100), S( 100, 100), S( 100, 100), S( 100, 100), S( 100, 100),
        },
        {
                S( 232, 339), S( 282, 379), S( 327, 411), S( 413, 373), S( 449, 382), S( 273, 403), S( 370, 346), S( 296, 276),
                S( 327, 386), S( 347, 425), S( 438, 401), S( 425, 434), S( 410, 422), S( 472, 380), S( 411, 379), S( 380, 370),
                S( 319, 414), S( 428, 411), S( 413, 450), S( 437, 449), S( 495, 426), S( 552, 411), S( 444, 414), S( 425, 374),
                S( 375, 407), S( 384, 444), S( 406, 461), S( 424, 468), S( 400, 465), S( 434, 457), S( 394, 444), S( 415, 399),
                S( 357, 407), S( 378, 421), S( 393, 454), S( 385, 462), S( 403, 461), S( 383, 463), S( 402, 427), S( 366, 398),
                S( 339, 386), S( 363, 420), S( 375, 437), S( 376, 450), S( 399, 443), S( 385, 412), S( 383, 410), S( 342, 395),
                S( 322, 377), S( 317, 407), S( 357, 408), S( 378, 412), S( 370, 423), S( 388, 395), S( 368, 379), S( 355, 377),
                S( 234, 376), S( 343, 361), S( 309, 409), S( 340, 405), S( 353, 391), S( 368, 380), S( 347, 364), S( 307, 350),
        },
        {
                S( 344, 382), S( 343, 379), S( 298, 385), S( 294, 384), S( 303, 385), S( 316, 385), S( 378, 366), S( 348, 375),
                S( 327, 388), S( 368, 387), S( 346, 389), S( 361, 373), S( 377, 377), S( 406, 366), S( 360, 377), S( 332, 367),
                S( 346, 390), S( 375, 380), S( 390, 369), S( 392, 373), S( 411, 369), S( 466, 370), S( 422, 379), S( 383, 387),
                S( 340, 380), S( 362, 386), S( 383, 377), S( 398, 387), S( 375, 387), S( 394, 380), S( 361, 389), S( 356, 393),
                S( 363, 379), S( 368, 380), S( 365, 387), S( 378, 390), S( 386, 376), S( 354, 379), S( 359, 380), S( 371, 377),
                S( 359, 381), S( 375, 380), S( 367, 383), S( 366, 391), S( 362, 383), S( 368, 371), S( 370, 376), S( 357, 379),
                S( 375, 366), S( 367, 361), S( 371, 367), S( 354, 378), S( 360, 377), S( 380, 361), S( 384, 360), S( 360, 356),
                S( 324, 373), S( 351, 375), S( 349, 357), S( 339, 375), S( 362, 371), S( 340, 375), S( 342, 372), S( 327, 367),
        },
        {
                S( 564, 749), S( 559, 756), S( 569, 758), S( 582, 756), S( 603, 746), S( 600, 751), S( 627, 742), S( 659, 725),
                S( 528, 778), S( 521, 784), S( 558, 778), S( 576, 774), S( 589, 760), S( 629, 735), S( 584, 754), S( 589, 751),
                S( 503, 776), S( 530, 772), S( 523, 775), S( 553, 762), S( 570, 751), S( 596, 741), S( 621, 732), S( 567, 738),
                S( 474, 768), S( 498, 765), S( 510, 771), S( 529, 758), S( 527, 755), S( 541, 755), S( 538, 747), S( 498, 755),
                S( 460, 760), S( 474, 763), S( 485, 768), S( 496, 759), S( 522, 742), S( 491, 742), S( 527, 739), S( 468, 752),
                S( 449, 752), S( 471, 754), S( 480, 750), S( 490, 744), S( 507, 736), S( 508, 722), S( 508, 738), S( 472, 732),
                S( 448, 756), S( 480, 745), S( 483, 751), S( 495, 748), S( 508, 736), S( 514, 725), S( 505, 735), S( 415, 760),
                S( 479, 739), S( 489, 744), S( 499, 754), S( 514, 747), S( 520, 734), S( 517, 741), S( 444, 768), S( 467, 739),
        },
        {
                S(1104, 1267), S(1080, 1316), S(1090, 1323), S(1125, 1290), S(1166, 1286), S(1248, 1250), S(1276, 1212), S(1190,1281),
                S(1076, 1292), S(1051, 1314), S(1078, 1334), S(1050, 1375), S(1049, 1382), S(1173, 1298), S(1119, 1319), S(1209,1266),
                S(1094, 1277), S(1080, 1283), S(1080, 1289), S(1093, 1314), S(1135, 1318), S(1192, 1294), S(1186, 1294), S(1155,1318),
                S(1078, 1275), S(1074, 1298), S(1066, 1298), S(1073, 1313), S(1092, 1310), S(1094, 1322), S(1098, 1343), S(1102,1341),
                S(1081, 1264), S(1063, 1286), S(1074, 1272), S(1092, 1271), S(1086, 1284), S(1082, 1296), S(1093, 1312), S(1095,1311),
                S(1081, 1238), S(1092, 1234), S(1080, 1260), S(1081, 1247), S(1082, 1254), S(1095, 1259), S(1101, 1288), S(1088,1284),
                S(1065, 1253), S(1092, 1230), S(1100, 1216), S(1096, 1234), S(1098, 1237), S(1127, 1186), S(1096, 1197), S(1102,1228),
                S(1099, 1224), S(1081, 1231), S(1086, 1232), S(1110, 1213), S(1101, 1226), S(1076, 1222), S(1055, 1221), S(1063,1205),
        },
        {
                S( -12, -57), S(  78, -24), S( 106, -29), S(  49,  -3), S(   8,  14), S(  14,  26), S(  45,  23), S(  15, -14),
                S(  77,  -9), S(  30,  34), S(  21,  32), S(  68,  23), S(  18,  31), S(  19,  49), S(  11,  56), S( -40,  28),
                S(  43,  10), S(  29,  34), S(  16,  38), S(  17,  32), S(   8,  37), S(  50,  48), S(  41,  57), S(  -6,  32),
                S(  11,   1), S(   9,  30), S(  -2,  39), S( -15,  41), S( -18,  39), S(   9,  42), S(  13,  38), S( -51,  21),
                S( -38,  -4), S(  22,   2), S(   1,  25), S( -36,  34), S( -26,  34), S( -18,  30), S( -27,  21), S( -53,   2),
                S(  17, -23), S(  13,  -2), S( -16,  14), S( -33,  24), S( -34,  26), S( -29,  19), S(   0,   5), S( -32,  -3),
                S(  26, -29), S(  -6,  -4), S( -18,   8), S( -65,  17), S( -45,  17), S( -19,   7), S(  14,  -6), S(  26, -24),
                S( -44, -38), S(  19, -28), S(   2, -12), S( -72,  -5), S(   4, -33), S( -46,  -5), S(  33, -30), S(  25, -52),
        },
};
constexpr int32_t passer[8] = {
        0, S(   8, 130), S(  10, 150), S(  12,  69), S( -12,  34), S(  -8,   3), S(   0,  -7), 0, };
constexpr int32_t bishop_pair = S(  45, 135);
constexpr int32_t mobility[8] = {
        S(   4,   8), S(   7,   2), S(   2,   9), };

constexpr uint64_t passed_pawn_mask[2][64] = {
        {
                0x0303030303030300, 0x0707070707070700, 0x0e0e0e0e0e0e0e00, 0x1c1c1c1c1c1c1c00, 0x3838383838383800, 0x7070707070707000, 0xe0e0e0e0e0e0e000, 0xc0c0c0c0c0c0c000,
                0x0303030303030000, 0x0707070707070000, 0x0e0e0e0e0e0e0000, 0x1c1c1c1c1c1c0000, 0x3838383838380000, 0x7070707070700000, 0xe0e0e0e0e0e00000, 0xc0c0c0c0c0c00000,
                0x0303030303000000, 0x0707070707000000, 0x0e0e0e0e0e000000, 0x1c1c1c1c1c000000, 0x3838383838000000, 0x7070707070000000, 0xe0e0e0e0e0000000, 0xc0c0c0c0c0000000,
                0x0303030300000000, 0x0707070700000000, 0x0e0e0e0e00000000, 0x1c1c1c1c00000000, 0x3838383800000000, 0x7070707000000000, 0xe0e0e0e000000000, 0xc0c0c0c000000000,
                0x0303030000000000, 0x0707070000000000, 0x0e0e0e0000000000, 0x1c1c1c0000000000, 0x3838380000000000, 0x7070700000000000, 0xe0e0e00000000000, 0xc0c0c00000000000,
                0x0303000000000000, 0x0707000000000000, 0x0e0e000000000000, 0x1c1c000000000000, 0x3838000000000000, 0x7070000000000000, 0xe0e0000000000000, 0xc0c0000000000000,
                0x0300000000000000, 0x0700000000000000, 0x0e00000000000000, 0x1c00000000000000, 0x3800000000000000, 0x7000000000000000, 0xe000000000000000, 0xc000000000000000,
                000000000000000000, 000000000000000000, 000000000000000000, 000000000000000000, 000000000000000000, 000000000000000000, 000000000000000000, 000000000000000000,
        },
        {
                000000000000000000, 000000000000000000, 000000000000000000, 000000000000000000, 000000000000000000, 000000000000000000, 000000000000000000, 000000000000000000,
                0x0000000000000003, 0x0000000000000007, 0x000000000000000e, 0x000000000000001c, 0x0000000000000038, 0x0000000000000070, 0x00000000000000e0, 0x00000000000000c0,
                0x0000000000000303, 0x0000000000000707, 0x0000000000000e0e, 0x0000000000001c1c, 0x0000000000003838, 0x0000000000007070, 0x000000000000e0e0, 0x000000000000c0c0,
                0x0000000000030303, 0x0000000000070707, 0x00000000000e0e0e, 0x00000000001c1c1c, 0x0000000000383838, 0x0000000000707070, 0x0000000000e0e0e0, 0x0000000000c0c0c0,
                0x0000000003030303, 0x0000000007070707, 0x000000000e0e0e0e, 0x000000001c1c1c1c, 0x0000000038383838, 0x0000000070707070, 0x00000000e0e0e0e0, 0x00000000c0c0c0c0,
                0x0000000303030303, 0x0000000707070707, 0x0000000e0e0e0e0e, 0x0000001c1c1c1c1c, 0x0000003838383838, 0x0000007070707070, 0x000000e0e0e0e0e0, 0x000000c0c0c0c0c0,
                0x0000030303030303, 0x0000070707070707, 0x00000e0e0e0e0e0e, 0x00001c1c1c1c1c1c, 0x0000383838383838, 0x0000707070707070, 0x0000e0e0e0e0e0e0, 0x0000c0c0c0c0c0c0,
                0x0003030303030303, 0x0007070707070707, 0x000e0e0e0e0e0e0e, 0x001c1c1c1c1c1c1c, 0x0038383838383838, 0x0070707070707070, 0x00e0e0e0e0e0e0e0, 0x00c0c0c0c0c0c0c0,
        }
};

template <Color color>
std::int16_t evaluate(board & chessboard) {
    std::int32_t eval = 0;
    std::int16_t game_phase = 0;

    for (Piece piece : {Pawn, Knight, Bishop, Rook, Queen, King}) {
        std::uint64_t bitboard = chessboard.get_pieces(White, piece) ;
        while (bitboard) {
            int square = pop_lsb(bitboard) ^ 56;
            eval += piece_square_tables[piece][square];
            game_phase += game_phase_increment[piece];
        }
    }

    for (Piece piece : {Pawn, Knight, Bishop, Rook, Queen, King}) {
        std::uint64_t bitboard = chessboard.get_pieces(Black, piece) ;
        while (bitboard) {
            int square = pop_lsb(bitboard);
            eval -= piece_square_tables[piece][square];
            game_phase += game_phase_increment[piece];
        }
    }

    if (popcount(chessboard.get_pieces(White, Bishop)) == 2) {
        eval += bishop_pair;
    }

    if (popcount(chessboard.get_pieces(Black, Bishop)) == 2) {
        eval -= bishop_pair;
    }

    uint64_t wp, bp, white_pawns, black_pawns;
    wp = white_pawns = chessboard.get_pieces(White, Pawn);
    bp = black_pawns = chessboard.get_pieces(Black, Pawn);
    int white_pawn_count = popcount(wp);
    int black_pawn_count = popcount(bp);

    if ((white_pawn_count + black_pawn_count) == 0 && game_phase < 2) {
        return 0;
    }

    while(wp) {
        int square = pop_lsb(wp);
        if ((passed_pawn_mask[White][square] & black_pawns) == 0) {
            eval += passer[(square >> 3) ^ 7];
        }
    }

    while(bp) {
        int square = pop_lsb(bp);
        if ((passed_pawn_mask[Black][square] & white_pawns) == 0) {
            eval -= passer[(square >> 3)];
        }
    }

    uint64_t occ = chessboard.get_occupancy();
    uint64_t bitboard = chessboard.get_pieces(White, Bishop);
    while (bitboard) {
        eval += mobility[0] * popcount(attacks<Ray::BISHOP>(pop_lsb(bitboard), occ));
    }

    bitboard = chessboard.get_pieces(Black, Bishop);
    while (bitboard) {
        eval -= mobility[0] * popcount(attacks<Ray::BISHOP>(pop_lsb(bitboard), occ));
    }

    bitboard = chessboard.get_pieces(White, Rook);
    while (bitboard) {
        eval += mobility[1] * popcount(attacks<Ray::ROOK>(pop_lsb(bitboard), occ));
    }

    bitboard = chessboard.get_pieces(Black, Rook);
    while (bitboard) {
        eval -= mobility[1] * popcount(attacks<Ray::ROOK>(pop_lsb(bitboard), occ));
    }

    bitboard = chessboard.get_pieces(White, Queen);
    while (bitboard) {
        eval += mobility[2] * popcount(attacks<Ray::QUEEN>(pop_lsb(bitboard), occ));
    }

    bitboard = chessboard.get_pieces(Black, Queen);
    while (bitboard) {
        eval -= mobility[2] * popcount(attacks<Ray::QUEEN>(pop_lsb(bitboard), occ));
    }

    game_phase = std::min(game_phase, max_game_phase_value);

    auto mg_eval = static_cast<int16_t>(eval);
    auto eg_eval = static_cast<int16_t>(eval >> 16);

    if constexpr (color == White) {
        return static_cast<std::int16_t>( (mg_eval * game_phase + eg_eval * (24 - game_phase)) / 24);
    } else {
        return static_cast<std::int16_t>(-(mg_eval * game_phase + eg_eval * (24 - game_phase)) / 24);
    }
}


#endif //MOTOR_EVALUATION_HPP
